# :::: LIBRARY IMPORTS ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
from nrf24 import (
    NRF24,

    RF24_DATA_RATE,
    RF24_PA,
    RF24_RX_ADDR,
)

import pigpio
import struct
import time
import sys
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::





# :::: CONSTANTS/GLOBALS ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
CE_PIN  = 22

ACK_TIMEOUT_S = 0.05          # <<< tiempo máx esperando ACK manual (50 ms)
MAX_ATTEMPTS  = 3             # <<< reintentos por paquete (puedes ajustar)
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::






# :::: HELPER FUNCTIONS :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
def INFO(message: str) -> None:
    """
    Prints a message to the console with the blue prefix `[INFO]:`
    """
    print(f"\033[34m[INFO]:\033[0m {message}")



def SUCC(message: str) -> None:
    """
    Prints a message to the console with the green prefix `[SUCC]:`
    """
    print(f"\033[32m[SUCC]:\033[0m {message}")


def ERROR(message: str) -> None:
    """
    Prints a message to the console with the red prefix `[~ERR]:`
    """
    print(f"\033[31m[~ERR]:\033[0m {message}")
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::





# :::: ROLE CONFIG  :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
role = ""

option_is_valid = False
while not option_is_valid:
    val = input("\033[33m[>>>>]:\033[0m Please choose a role for this device [T]ransmitter, [R]eceiver, [C]arrier, [Q]uit: ")
    try:
        val = val.upper()

        if val == "T":
            INFO('Device set to TRANSMITTER role')
            role = "T"
            option_is_valid = True
        
        elif val == "R":
            INFO('Device set to RECEIVER role')
            role = "R"
            option_is_valid = True

        elif val == "C":
            INFO('Device set to CONSTANT CARRIER role')
            role = "C"
            option_is_valid = True
        
        elif val == "Q":
            INFO('Quitting program...')
            role = "Q"
            option_is_valid = True
        
        else:
            continue

    except:
        continue
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::





# :::: RADIO CONFIG :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

# pigpio
hostname = "localhost"
port     = 8888

pi = pigpio.pi(hostname, port)
if not pi.connected:
    ERROR("Not connected to Raspberry Pi, exiting")
    sys.exit(1)

# radio object
nrf = NRF24(pi, ce = CE_PIN)


# radio channel
nrf.set_channel(76)


# data rate
nrf.set_data_rate(RF24_DATA_RATE.RATE_1MBPS)


# Tx/Rx power
nrf.set_pa_level(RF24_PA.MIN)


# CRC
nrf.enable_crc()
nrf.set_crc_bytes(2)


# global payload 
nrf.set_payload_size(32) # [1 - 32] Bytes
payload:list[bytes] = []

PAYLOAD_SIZE = nrf.get_payload_size()   # <<< atajo local

# Format: <H B>  -> burst_id (uint16), ptype (uint8)
PTYPE_DATA  = 0
PTYPE_ACK   = 1

HEADER_FMT  = "<HHB"         # 2 + 1 = 3 bytes
HEADER_SIZE = 3              # header length
DATA_MAX    = PAYLOAD_SIZE - HEADER_SIZE   # 30 bytes of real data


# auto-retries
# nrf.set_retransmission(1, 15) #Retransmitting (1+1)*250ms and just 15 times will try it. Automatic ACKs


# Tx/Rx addresses
nrf.set_address_bytes(4) # [2 - 5] Bytes
possible_addreses = [b"TAN1", b"TAN2"] # Team A Node X 
address = ""


address_is_valid = False
while not address_is_valid:
    val = input("\033[33m[>>>>]:\033[0m Please choose a value for the address [0: TAN1, 1: TAN2]: ")
    try:
        val = int(val)

        if val == 0:
            INFO(f'Address set to {possible_addreses[0]}')
            address_is_valid = True

            # --- Open both sides to enable the ACK --------------------
            nrf.open_reading_pipe(RF24_RX_ADDR.P1, possible_addreses[0])   # pipe for RX
            nrf.open_writing_pipe(possible_addreses[1])                    # pipe for TX
            # -------------------------------------------------------------------

        if val == 1:
            INFO(f'Address set to {possible_addreses[1]}')
            address_is_valid = True

            # --- Open both sides to enable the ACK --------------------
            nrf.open_reading_pipe(RF24_RX_ADDR.P1, possible_addreses[1])   # pipe for Rx
            nrf.open_writing_pipe(possible_addreses[0])                    # pipe for TX
            # -------------------------------------------------------------------
        
        else:
            continue

    except:
        continue


# === DESACTIVATE AUTO-ACK DE HARDWARE (EN_AA=0) TO MAKE ACKz MANUALS=========
def _disable_auto_ack(nrf_obj):
    nrf_obj.unset_ce()
    nrf_obj._nrf_write_reg(nrf_obj.EN_AA, 0x00)   # <<< disable auto-ack for all pipes
    nrf_obj.set_ce()

_disable_auto_ack(nrf) 
# =================================================================================

# === Make packets=========
def make_data_pkt(burst_id: int, chunk: bytes) -> bytes:
    """Build a DATA packet: header + chunk, padded to 32 bytes."""
    chunk = chunk[:DATA_MAX]                        # don't overflow payload
    body  = struct.pack(HEADER_FMT, burst_id, PTYPE_DATA) + chunk # struct.pack(fmt, v1, v2, v3, ...)
    return body + b"\x00" * (PAYLOAD_SIZE - len(body))  # pad to 32

def make_ack_pkt(burst_id: int,  int) -> bytes:
    """Build an ACK for that burst (no extra data), padded to 32."""
    body = struct.pack(HEADER_FMT, burst_id, PTYPE_ACK)
    return body + b"\x00" * (PAYLOAD_SIZE - len(body))

def parse_pkt(pkt: bytes):
    """Return (burst_id, ptype, data_bytes) from a raw 32B payload."""
    hdr = pkt[:HEADER_SIZE]
    burst_id, ptype = struct.unpack(HEADER_FMT, hdr)
    data = pkt[HEADER_SIZE:]                        # rest is data (padded)
    return burst_id, ptype, data


# status visualization
INFO(f"Radio details:")
nrf.show_registers()
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::



# :::: FLOW FUNCTIONS :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
def _send_ack_packet() -> None:
    ack = b"ACK" + b"\x00"*(PAYLOAD_SIZE-3)        # Fix payload for the "ACK" + padding
    nrf.send(ack)                                  # Send messages
    nrf.wait_until_sent()                         


def _wait_for_ack(timeout_s: float) -> bool:
    t0 = time.monotonic()
    nrf.power_up_rx()                               # From Rx to Tx
    while (time.monotonic() - t0) < timeout_s:
        if nrf.data_ready():                        # If something arrives we consider the ACK
            _ = nrf.get_payload()                   # Read without parsing
            return True
        time.sleep(0.001)
    return False


burst_id_counter = 1

def BEGIN_TRANSMITTER_MODE() -> None:
    """
    Transmits the first txt file found in the mounted USB
    """

    INFO('Starting transmission (manual ACK)')

    try:
        # open the file to read
        with open("file_to_send.txt", "rb") as file:
            content = file.read()

        content_len = len(content)
        INFO(f'Read {content_len} raw bytes read from file_to_send.txt: {content}')


        # split the contents into chunks
        chunks = [
            content[ii:i+DATA_MAX]
            for i in range(0, content_len, DATA_MAX)
        ]
        chunks_len = len(chunks) # número total de chunks

        packets = []
        for chunk in chunks:
            packets.append(struct.pack(f"<{nrf.get_payload_size()}s", chunk))

    
        nrf.power_up_tx()                           
        start = time.monotonic()          
        for idx in range(chunks_len):
            attempt = 1
            sent_ok = False

            while attempt <= MAX_ATTEMPTS:          # Manual attempts
                INFO(f"Sending packet #{idx} (attempt {attempt}): {chunks[idx]} --> {packets[idx]}")

                nrf.reset_packages_lost()           
                nrf.send(packets[idx])              # Data send

                try:
                    tic = time.monotonic_ns()
                    nrf.wait_until_sent()           # Wait until sent
                    tac = time.monotonic_ns()
                except TimeoutError:
                    ERROR("Timeout while transmitting")

                # Wait for the reception of the ACK
                got_ack = _wait_for_ack(ACK_TIMEOUT_S)    # Listen to RX for ACK

                if got_ack:
                    ack_rtt_ms = (time.monotonic() - start) * 1000.0  # RTT of the manual ACK
                    SUCC(f"[ACK] pkt#{idx} ok | app_retries={attempt-1} | tx_time={(tac - tic)/1000:.1f} us | ack_rtt={ack_rtt_ms:.2f} ms")
                    sent_ok = True
                    nrf.power_up_tx()        # We return to TX mode to start trasnmitting the next packet
                    break
                else:
                    ERROR(f"No manual ACK for packet #{idx}")
                    nrf.power_up_tx()               # We try to retrasnmit the packet
                    attempt += 1
                    time.sleep(0.005)

            if not sent_ok:
                ERROR(f"Giving up packet #{idx} after {MAX_ATTEMPTS} attempts")
                # break

            time.sleep(0.2) 

    finally:
        nrf.power_down()
        pi.stop()
    
    return










def BEGIN_RECEIVER_MODE() -> None:
    """
    Receives multiple frames from a transmitter and reassembles the blocks into a
    txt file
    (responde con ACKs manuales tras cada recepción)
    """

    INFO('Starting reception (manual ACK)')

    try:
        # empezar oyendo
        nrf.power_up_rx()                           # MODE RX

        # start the timers
        tic     = time.monotonic()
        tac     = time.monotonic()
        timeout = 20
        INFO(f'Timeout set to {timeout} seconds')

        chunks = []
        while (tac - tic) < timeout:
            tac = time.monotonic()

            # check if there are frames
            while nrf.data_ready():

                payload_pipe = nrf.data_pipe()

                packet = nrf.get_payload()

                chunk: bytes = struct.unpack(f"<{nrf.get_payload_size()}s", packet)[0]
                chunks.append(chunk)
                
                SUCC(f"Received {len(chunk)} bytes on pipe {payload_pipe}: {packet} --> {chunk}")

                # --- SEND ACK --------------------------------
                nrf.power_up_tx()                   
                _send_ack_packet()                  
                nrf.power_up_rx()                 
                # -----------------------------------------------------------------

                tic = time.monotonic()
            
            time.sleep(.1)

        INFO('Connection timed-out')
        
        
        INFO('Collected:')
        for chunk in chunks:
            print(f"    {chunk}")
        

        content = bytes()
        for chunk in chunks:
            content += chunk
        INFO(f'Merged data: {content}')
    

        if len(content) == 0:
            ERROR('Did not receive anything')
            return
        
        
        with open("file_received.txt", "wb") as f:
            f.write(content)
        content_len = len(content)
        SUCC(f'Saved {content_len} bytes to: file_received.txt')

    finally:
        nrf.power_down()
        pi.stop()

    return










def BEGIN_CONSTANT_CARRIER_MODE() -> None:
    """
    Transmits a constant carrier until the user exits with CTRL+C
    """
    
    ERROR("TODO")
    return
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::





# :::: MAIN :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
def main():
    match role:
        case "T":
            BEGIN_TRANSMITTER_MODE()
            return
        
        case "R":
            BEGIN_RECEIVER_MODE()
            return
        
        case "C":
            BEGIN_CONSTANT_CARRIER_MODE()
            return
        
        case "Q":
            return
        
    return
# :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::




if __name__ == "__main__":
    main()
